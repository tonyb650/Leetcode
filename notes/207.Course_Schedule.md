### 207. Course Schedule

**Problem**\
There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.

For example, the `pair [0, 1]`, indicates that to take course `0` you have to first take course `1`.
Return `true` if you can finish all courses. Otherwise, return `false`.

**Example 1:**\
Input: numCourses = 2, prerequisites = [[1,0]]\
Output: true\
Explanation: There are a total of 2 courses to take. \
To take course 1 you should have finished course 0. So it is possible.

**Example 2:**\
Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\
Output: false\
Explanation: There are a total of 2 courses to take.\ 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.

**Constraints:**
- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- All the pairs prerequisites[i] are **unique**.

### Solution, Cycle Detection with White-Grey-Black algorithm
```js
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    const visited = new Set() // "black"
    const visiting = new Set() // "grey"
    
    const list = adjList(numCourses, prerequisites) // Need to convert list of edges to adjacency list
    
    for (let node in list) {
        if (findCycle(node, list, visited, visiting)===true) {
            return false
        }
    }
    return true
};

const findCycle = (node, list, visited, visiting) => {
    if (visited.has(node)) return false // found a "black"
    if (visiting.has(node)) return true // cycle found (encountered a "grey")

    visiting.add(node)
    const neighbors = list[node]
    for (let neighbor of neighbors) {
        if(findCycle(neighbor, list, visited, visiting) === true) return true
    }
    visiting.delete(node)
    visited.add(node)

    return false
}

const adjList = (n, edges) => {
    const list = {}
    Array(n).fill(0).forEach((_,i)=> list[i] = [])
    for (let edge of edges) {
        const [to, from] = edge
        list[to].push(String(from))
    }
    return list
}
```