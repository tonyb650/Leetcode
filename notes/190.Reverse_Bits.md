### 190. Reverse Bits

**Problem**
Reverse bits of a given 32 bits unsigned integer.

Note:
- Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using 2's complement notation.

**Example 1:**\
Input: n = 43261596\
Output: 964176192

Explanation:

| Integer     | Binary                             |
| ----------- | ---------------------------------- |
| `43261596`  | `00000010100101000001111010011100` |
| `964176192` | `00111001011110000010100101000000` |


**Example 2:**\
Input: n = 2147483644\
Output: 1073741822

Explanation:

| Integer     | Binary                             |
| ----------- | ---------------------------------- |
| `2147483644`  | `01111111111111111111111111111100` |
| `1073741822` | `00111111111111111111111111111110` |


**Constraints:**
- 0 <= n <= 231 - 2
- n is even.
 

**Follow up:** If this function is called many times, how would you optimize it?

### Solution, Javascript
```javascript
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    let result = 0
    let firstBit = 0
    // loop from 1-32
    for(let i=0; i <32; i++){
        // Zero fill left shift result 
        result = result << 1
        // determine right-most bit of 'n'
        let bit = n % 2 //? 0 : 1
        if (i===0) {
          firstBit = bit
          bit = 0
        }
        // if bit is 1, add 1 to result
        result += bit
        // Zero fill right shift 'n'
        n = n >>> 1
    }
    if (firstBit) result = result + 2**31
    return result 
};
```