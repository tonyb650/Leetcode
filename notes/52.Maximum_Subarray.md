### 53. Maximum Subarray

**Problem**\
Given an integer array `nums`, find the subarray with the largest sum, and return *its sum*.

**Example 1:**\
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\
Output: 6\
Explanation: The subarray [4,-1,2,1] has the largest sum 6.

**Example 2:**\
Input: nums = [1]\
Output: 1\
Explanation: The subarray [1] has the largest sum 1.

**Example 3:**\
Input: nums = [5,4,-1,7,8]\
Output: 23\
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

**Constraints:**
- 1 <= nums.length <= 105
- -104 <= nums[i] <= 104

### Solution, Brute Force: O (n^2)
```js
var maxSubArray = function(nums) {
  let max = -Infinity
  for (let i = 0; i < nums.length; i++) {
      let total = 0
      for (let j = i; j < nums.length; j++) {
          total += nums[j]
          max = Math.max(max, total)
      }
  }
  return max
};
```
### Solution, Dynamic Programming: O (n)
```js
var maxSubArray = function(nums) {
    let maxSoFar = -Infinity
    let currentRun = -Infinity
    for (let num of nums) {
        if (currentRun < 0) { // past numbers are worthless
            if (num < 0){     // they continue to be worthless
                currentRun = -Infinity
            } else {          // starting over with a positive value
                currentRun = num
            }
        } else {              // past numbers add value
            if (currentRun + num < 0) { // but current value means we start over
                currentRun = -Infinity
            } else {          // currentRun has not turned negative, so let's keep it going and see where it goes...
                currentRun += num
            }
        }
        maxSoFar = Math.max(num, currentRun, maxSoFar)
    }
    return maxSoFar
};
```

### Solution, Dynamic Programming, refactored
```js
var maxSubArray = function(nums) {
    let maxSoFar = nums[0]
    let currentRun = nums[0]
    for (let num of nums) {
        currentRun = Math.max(num, currentRun + num);
        maxSoFar = Math.max(maxSoFar, currentRun);
    }
    return maxSoFar
};
```
